[
  
  {
    "title": "C primer plus Notes",
    "url": "/posts/C-primer-plus-notes-12/",
    "categories": "C",
    "tags": "Coding, Notes",
    "date": "2023-04-06 18:10:36 +0800",
    





    
    "snippet": "C primer plus Notes12 存储类别、链接和内存管理关键字：auto，extern，static, register, const, volatile, restricted, _Thread_local, _Atomic函数：rand(), srand(), time(), malloc(), free()12.1存储类别C语言把一块内存称为 对象int entity = ...",
    "content": "C primer plus Notes12 存储类别、链接和内存管理关键字：auto，extern，static, register, const, volatile, restricted, _Thread_local, _Atomic函数：rand(), srand(), time(), malloc(), free()12.1存储类别C语言把一块内存称为 对象int entity = 3该声明创建了一个名为entity的 标识符（identifier）。标识符不是指定对象的唯一途径。int *pt = &amp;entity;int ranks[10];可以用存储期（Storage duration）描述对象，指对象在内存中保留了多次时间。标识符用于访问对象，可以用作用域(scope)和链接（linkage）描述标识符，表明程序的哪些部分可以使用它。12.1.1 作用域一个C变量的作用域，可以是块作用域（block scope）、函数作用域、函数原型作用域、文件作用域块（block） 是一对花括号括起来的区域，块作用域变量的可见范围是从定义处到包含该定义的块的结尾，也就是说包括形式参数。我们使用的局部变量都具有块作用域。从C99开始，在块中任意位置都可以声明变量。块的概念扩展到了for、while、do while、if等函数控制的语句。函数作用域 仅作用于go to语句的标签。函数原型作用域（function prototype scope） 用于函数原型中的形参名（变量名）。如 int mighty(int mouse, double large); 函数原型作用域的范围是从形参定义处到函数结束。编译器在处理函数原型中的形参时只关心它的类型，形参名无关紧要。形参名也不必与函数中的形参名相匹配。只有在变长数组中，形参名才有用： void use_a_VLA(int n, int m, ar[n][m]); 例子中，n和m必须使用已经在函数原型中声明过的形参。文件作用域(file scope) 变量的定义在函数的外面，也称为全局变量（global variable） ,如以下代码中的units变量。#include &lt;stdio.h&gt;int units = 0; int main(void){    ...}翻译单元（translation units） ：编译器把源代码中的头文件内容替换#include指令，因此一个源代码和其头文件共同构成一个翻译单元，文件作用域实际上作用于整个翻译单元。如果程序由多个源代码文件组成，那么该程序也将由多个翻译单元组成。12.1.2 链接C变量有3种链接属性:外部链接、内部链接或无链接。无链接变量：具有块作用域、函数作用域或函数原型作用域的变量。这些变量属于定义它们的块、函数或原型私有。具有文件作用域的变量可以是外部链接或内部链接。外部链接变量可以在多文件程序中使用，内部链接变量只能在一个翻译单元中使用。因此：内部链接：文件作用域。 例如static int dodgers = 3;,仅作用于本翻译单元。外部链接：全局作用域（或程序作用域）。例如int giant = 5;作用于同一程序的所有文件（翻译单元）。12.1.3 存储器作用域和链接描述了标识符的可见性。存储期描述了通过这些标识符访问的对象的生存期。C对象有4种存储期：静态存储期、线程存储期、自动存储期、动态分配存储期。静态存储期：在程序的执行期间一直存在。文件作用域变量具有静态存储期。注意，对于文件作用域变量，关键字 static 表明了其链接属性，而非存储期。以 static 声明的文件作用域变量具有内部链接。但是无论是内部链接还是外部链接，所有的文件作用域变量都具有静态存储期。线程存储期：用于并发程序设计，程序执行可被分为多个线程。具有线程存储期的对象，从被声明时到线程结束一直存在。以关键字 Thread local声明一个对象时，每个线程都获得该变量的私有备份。自动存储期：大部分 块作用域 的变量。当程序进入定义这些变量的块时，为这些变量分配内存;当退出这个块时，释放刚才为变量分配的内存。这种做法相当于把自动变量占用的内存视为一个可重复使用的工作区或暂存区。例如，一个函数调用结束后，其变量占用的内存可用于储存下一个被调用函数的变量。变长数组稍有不同，它们的存储期从声明处到块的末尾，而不是从块的开始处到块的末尾。块作用域变量也能具有静态存储期。为了创建这样的变量，要把变量声明在块中，且在声明前面加上关键字static，例如以下代码：void more(int number){    int index;    static int ct = 0; //ct变量具有静态存储期，因为命名时有static    ...    return 0;}ct的作用域没有发生改变，只有执行该函数时，程序才能使用ct访问其对象。但由于具有静态存储期，该函数可以通过提供给其他函数该存储区的地址，就可以访问该对象，例如通过指针形参或返回值）。作用域、链接和存储期互相组合，具有5种存储类别（除去并发程序设计）。            存储类别      存储期      作用域      链接      声明方式                  自动      自动      块      无      块内              寄存器      自动      块      无      块内，使用关键字register              静态外部链接      静态      程序多个文件      外部      所有函数外              静态内部链接      静态      单个文件      内部      所有函数外，使用关键字static              静态无链接      静态      块      无      块内，使用static      12.1.4 自动变量声名在块或函数头中的变量一般都是自动变量。可以显式使用关键字 auto，表明有意覆盖一个外部变量定义，或者强调不要把该变量改为其他存储类别，如下所示:int main(void){    auto int plox;}auto在C和C++的定义完全不同，在C/C++兼容编程中不要使用。如果块的内层和外层定义了同名的变量，在内层块会隐藏外层快的定义。但是离开内层块后，外层块的作用域回到原来的作用域。#include &lt;stdio.h&gt;int x = 30;int main(){    while(x ++ &lt;33)    {        int x = 100;        x ++;        printf(\"x in while loop: %d at %p\\n\", x, &amp;x)    }    printf(\"x in outer block: %d at %p\\n\", x, &amp;x);}"
  }
  
]

