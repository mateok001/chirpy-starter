---
title: C primer plus Notes 13
date: 2023-06-07 15:14:36 +0800
categories: [C]
tags: [Coding, Notes]     # TAG names should always be lowercase
---

# C primer plus Notes 13

## 13 文件输入/输出

文件用于储存程序、文档、数据、书信、表格、图形、照片、视频和许多其他种类的信息。

### 13.1 与文件进行通信

有时，程序需要从文件中读取信息或把信息写入文件。这种程序与文件的交互形式就是文件重定向。这种方法很简单，但有一定的限制。

```c
books > bklist
//在一些交互性的程序中不适合
```

#### 13.1.1 文件是什么

文件通常是在磁盘或固态硬盘上的一段已命名的存储区。

C把文件看作一系列连续的字节，每个字节都能被单独读取。这与UNIX环境中的文件结构相对应。

其他环境可能无法完全对应这个模型，C提供两种文件模式：文本模式和二进制模式。

#### 13.1.2 文本模式和二进制模式

首先，要区分文本内容和二进制内容、文本文件格式和二进制文件格式，以及文件的文本模式和二进制模式。

所有文件的内容都以二进制形式(0或1)储存。

如果文件最初使用二进制编码的字符(例如ASCII或Unicode)表示文本(就像C字符串那样)，该文件就是文本文件，其中包含文本内容。

如果文件中的二进制值代表机器语言代码或数值数据(使用相同的内部表示，假设，用于 long 或 double 类型的值)或图片或音乐编码，该文件就是二进制文件，其中包含二进制内容。

对于文本文件：C和UNIX保持一致，以\n表示换行。UNIX中有个统计文件大小的计数，程序根据此判断是否读到文件结尾。但是以前的OS X Mac文件则是用\r,ms-dos是用\r\n，用嵌入的CTRL+Z字符表示文件结尾。

C访问文件的文本模式：读取时自动将不同系统的\r、\r\n映射为\n，将文件结尾映射为C结尾；写入时则是将\n映射回原来的形式。

C访问文件的二进制模式：不进行映射，直接展示原换行和结尾字符。

#### 13.1.3 I/O的级别

IO有两种级别，系统底层IO和高级标准IO（C库标准包及stdio.h中定义）。

#### 13.1.4 标准文件

C程序会自动打开3个文件，它们被称为标准输入 (standardinput)、标准输出(standardoutput)和标准错误输出(standard error output)。

在默认情况下，标准输入是系统的普通输入设备，通常为键盘:标准输出和标准错误输出是系统的普通输出设备，通常为显示屏。

通常，标准输入为程序提供输入，它是 `getchar()`和 `scanf()`使用的文件。程序通常输出到标准输出，它是 `putchar()`、`puts()`和 `printf()`使用的文件。

重定向把其他文件视为标准输入或标准输出。

标准错误输出提供了一个逻辑上不同的地方来发送错误消息。例如，如果使用重定向把输出发送给文件而不是屏幕，那么发送至标准错误输出的内容仍然会被发送到屏幕上。这样很好，因为如果把错误消息发送至文件，就只能打开文件才能看到。


### 13.2 标准I/O

与底层I/0 相比，标准I/0 包除了可移植以外还有两个好处。

第一，标准 I/0 有许多专门的函数简化了处理不同I/0的问题。例如，`printf()`把不同形式的数据转换成与终端相适应的字符串输出。

第二，输入和输出都是缓冲的。也就是说，一次转移一大块信息而不是一字节信息(通常至少512 字节)。



#### 13.2.1 检查命令行参数

形参中的argc是命令行执行程序的参数数量，argv[]是参数的名称。

argc至少为1，因为程序本身命令也算，即argv[0]。本例中，argv[1]是用户输入的文件名。

程序一开始检查argc的值，查看是否有命令行参数。如果没有，程序将打印一行信息并退出。

在初始程序中，`exit()`和`return 0`的功能类似。如果 `main()`在一个递归程序中，`exit()`仍然会终止程序,但是`return`只会把控制权交给上一级递归,直至最初的一级。然后return结束程序。`return`和`exit()`的另一个区别是，即使在其他函数中(除`main()`以外)调用`exit()`也能结束整个程序。



#### 13.2.2 fopen()函数

|模式字符串|含义|
|---|---|
|"r"|读模式|
|"w"|写模式，现有文件长度截为0，没有文件则新建|
|"a"|写模式，现有文件末尾添加内容，没有文件则新建|
|"r+"|更新模式，可读写|
|"w+"|更新模式读写，现有文件长度截为0，没有文件则新建|
|"a+"|更新模式读写，现有文件末尾添加内容，没有文件则新建|
|"rb"、"wb"、"ab"等等|类似上方模式，但是二进制模式|
|"wx"、"wbx"、"w+x"|(c11)文件已存在或以独占模式打开文件，则打开失败|

linux和unix中，带b和不带b模式相同。

程序成功打开文件后，fopen()将返回文件指针(lepointer)，其他I/0函数可以使用这个指针指定该文件。

文件指针(该例中是 fp)的类型是指向 FILE 的指针，FILE 是一个定义在 stdio.h 中的派生类型。

文件指针 fp 并不指向实际的文件，它指向一个包含文件信息的数据对象，其中包含操作文件的I/O 函数所用的缓冲区信息。

因为标准库中的 I/O 函数使用缓冲区，所以它们不仅要知道缓冲区的位置，还要知道缓冲区被填充的程度以及操作哪一个文件。

标准 I/O 函数根据这些信息在必要时决定再次填充或清空缓冲区。fp 指向的数据对象包含了这些信息 (该数据对象是一个C结构)。

#### 13.2.3 putc()函数和getc()函数

```c
ch = getc(fp);//从fp指定的文件中获取一个字符
putsc(ch, fpout);//把字符ch放入FILE指针fpout指定的文件中
ch = getchar()；//从标准输入中获取一个字符
```

实际上，`getchar()`和`putchar()`就是通过`getc()`和`putc()`来定义的。

#### 13.2.4 文件结尾

如果`getc()`函数在读取一个字符时发现是文件结尾，它将返回一个特殊值`EOF`。

所以C程序只有在读到超过文件末尾时才会发现文件的结尾(一些其他语言用一个特殊的函数在读取之前测试文件结尾)。

为了避免读到空文件，应该使用入口条件循环进行文件输入,在while前先读取一个字节，把第一个字节EOF作为判断条件。

#### 13.2.5 fclose()函数

`fclose(fp)`函数关闭 fp 指定的文件，必要时刷新缓冲区。

对于较正式的程序，应该检查是否成功关闭文件。如果成功关闭，`fclose()`函数返回0，否则返回`EOF`。磁盘已满等情况可能导致关闭失败。

```c
if (fclose(fp) != 0)
    printf("Error in closing file %s\n", argv[1]);
```    

#### 13.2.6 指向标准文件的指针

stdio.h头文件把3个指针与3个标准文件相关联，C程序会自动打开这三个文件。

|标准文件|文件指针|通常使用的设备|
|---|---|---|
|标准输入|stdin|键盘|
|标准输出|stdout|显示器|
|标准错误|stderr|显示器|

这些文件指针都是指向 FILE 的指针，所以它们可用作标准I/0 函数的参数如 fcose(fp)中的 fp。

### 13.3 一个简单的文件压缩程序

```c
//reducto 把文件压缩成原来的1/3
#include <stdio.h>
#include <stdlib.h>  //提供exit原型
#include <string.h> //提供strcpy、strcat的原型
#define LEN 40

int main(int argc, char *argv[])
{
    FILE *in, *out; //声明两个指向FILE的指针
    int ch;
    char name[LEN]; //储存输出文件名
    int count = 0;

    // 检查命令行参数，若命令行参数少于2个，返回错误
    if (argc < 2)
    {
        fprintf(stderr, "Usage: %s filename\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    //设置输入
    if ((in = fopen(argv[1], "r")) == NULL)
    {
        fprintf(stderr, "I couldn't open the file\"%s\"\n", argv[1]);
        exit(EXIT_FAILURE);
    }

    //设置输出
    strcpy(name, argv[1], LEN-5);  //拷贝文件名
    name[LEN-5] = '\0';
    strcat(name, ".red");  //在文件名后面添加后缀.red
    if ((out = fopen(name, "w")) == NULL)
    {
        fprintf(stderr, "Can't create output file.\n");
        exit(3);
    }

    //拷贝数据
    while ((ch = getc(in)) != EOF)
        if (count++ % 3 == 0)
            putc(ch, out);

    //收尾工作
    if ((fclose(in) != 0) && (fclose(out) != 0))
        fprintf(stderr, "Error in closing files.\n");

    return 0; 
}
```