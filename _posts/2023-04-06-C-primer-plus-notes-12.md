---
title: C primer plus Notes 12
date: 2023-04-06 18:10:36 +0800
categories: [C]
tags: [Coding, Notes]     # TAG names should always be lowercase
---

# C primer plus Notes 12

## 12 存储类别、链接和内存管理

关键字：auto，extern，static, register, const, volatile, restricted, _Thread_local, _Atomic

函数：rand(), srand(), time(), malloc(), free()

### 12.1存储类别

C语言把一块内存称为 **对象**

```c
int entity = 3
```

该声明创建了一个名为entity的 **标识符（identifier）**。

标识符不是指定对象的唯一途径。

```c
int *pt = &entity;
int ranks[10];
```

可以用**存储期（Storage duration）**描述对象，指对象在内存中保留了多次时间。

标识符用于访问对象，可以用**作用域(scope)**和**链接（linkage）**描述标识符，表明程序的哪些部分可以使用它。

#### 12.1.1 作用域

一个C变量的作用域，可以是**块作用域（block scope）、函数作用域、函数原型作用域、文件作用域**

**块（block）** 是一对花括号括起来的区域，块作用域变量的可见范围是从定义处到包含该定义的块的结尾，也就是说包括形式参数。我们使用的局部变量都具有块作用域。

从C99开始，在块中任意位置都可以声明变量。块的概念扩展到了for、while、do while、if等函数控制的语句。

**函数作用域** 仅作用于go to语句的标签。

**函数原型作用域（function prototype scope）** 用于函数原型中的形参名（变量名）。如 ``int mighty(int mouse, double large);`` 函数原型作用域的范围是从形参定义处到函数结束。编译器在处理函数原型中的形参时只关心它的类型，形参名无关紧要。形参名也不必与函数中的形参名相匹配。只有在变长数组中，形参名才有用： ``void use_a_VLA(int n, int m, ar[n][m]);`` 例子中，n和m必须使用已经在函数原型中声明过的形参。

**文件作用域(file scope)** 变量的定义在函数的外面，也称为**全局变量（global variable）** ,如以下代码中的units变量。

```c
#include <stdio.h>
int units = 0; 
int main(void){
    ...
}
```

**翻译单元（translation units）** ：编译器把源代码中的头文件内容替换#include指令，因此一个源代码和其头文件共同构成一个翻译单元，文件作用域实际上作用于整个翻译单元。如果程序由多个源代码文件组成，那么该程序也将由多个翻译单元组成。

### 12.1.2 链接

C变量有3种链接属性:**外部链接**、**内部链接**或**无链接**。

无链接变量：具有块作用域、函数作用域或函数原型作用域的变量。这些变量属于定义它们的块、函数或原型私有。

具有文件作用域的变量可以是外部链接或内部链接。

外部链接变量可以在多文件程序中使用，内部链接变量只能在一个**翻译单元**中使用。

因此：

内部链接：文件作用域。 例如``static int dodgers = 3;``,仅作用于本翻译单元。

外部链接：全局作用域（或程序作用域）。例如``int giant = 5;``作用于同一程序的所有文件（翻译单元）。

### 12.1.3 存储期

作用域和链接描述了标识符的可见性。**存储期**描述了通过这些标识符访问的对象的生存期。

C对象有4种存储期：**静态存储期**、**线程存储期**、**自动存储期**、**动态分配存储期**。

**静态存储期**：在程序的执行期间一直存在。文件作用域变量具有静态存储期。
注意，对于文件作用域变量，关键字 static 表明了其链接属性，而非存储期。以 static 声明的文件作用域变量具有内部链接。但是无论是内部链接还是外部链接，所有的文件作用域变量都具有静态存储期。

**线程存储期**：用于并发程序设计，程序执行可被分为多个线程。具有线程存储期的对象，从被声明时到线程结束一直存在。以关键字 Thread local声明一个对象时，每个线程都获得该变量的私有备份。

**自动存储期**：大部分 块作用域 的变量。当程序进入定义这些变量的块时，为这些变量分配内存;当退出这个块时，释放刚才为变量分配的内存。这种做法相当于把自动变量占用的内存视为一个可重复使用的工作区或暂存区。例如，一个函数调用结束后，其变量占用的内存可用于储存下一个被调用函数的变量。变长数组稍有不同，它们的存储期从声明处到块的末尾，而不是从块的开始处到块的末尾。

块作用域变量也能具有静态存储期。为了创建这样的变量，要把变量声明在块中，且在声明前面加上关键字static，例如以下代码：
```c
void more(int number)
{
    int index;
    static int ct = 0; //ct变量具有静态存储期，因为命名时有static
    ...
    return 0;
}
```
``ct``的作用域没有发生改变，只有执行该函数时，程序才能使用``ct``访问其对象。但由于具有静态存储期，该函数可以通过提供给其他函数该存储区的地址，就可以访问该对象，例如通过指针形参或返回值）。

作用域、链接和存储期互相组合，具有5种存储类别（除去并发程序设计）。

|存储类别|存储期|作用域|链接|声明方式|
|---|---|---|---|---|
|自动|自动|块|无|块内|
|寄存器|自动|块|无|块内，使用关键字register|
|静态外部链接|静态|程序多个文件|外部|所有函数外|
|静态内部链接|静态|单个文件|内部|所有函数外，使用关键字static|
|静态无链接|静态|块|无|块内，使用static|

### 12.1.4 自动变量

声名在块或函数头中的变量一般都是自动变量。

可以显式使用关键字 ``auto``，表明有意覆盖一个外部变量定义，或者强调不要把该变量改为其他存储类别，如下所示:

```c
int main(void){
    auto int plox;
}
```
``auto``在C和C++的定义完全不同，在C/C++兼容编程中不要使用。

如果块的内层和外层定义了同名的变量，在内层块会隐藏外层快的定义。但是离开内层块后，外层块的作用域回到原来的作用域。

```c
#include <stdio.h>
int x = 30;
int main()
{
    while(x ++ <33)
    {
        int x = 100;
        x ++;
        printf("x in while loop: %d at %p\n", x, &x)
    }
    printf("x in outer block: %d at %p\n", x, &x);
}
```

### 12.1.5 寄存器变量

使用`regitster`来申请在寄存器中储存变量。
寄存器中变量储存速度更快，但是无法获取地址。

寄存器变量：块作用域，无链接，自动存储期。

编译器不一定会响应寄存器变量的申请。

### 12.1.6 块作用域的静态变量

静态变量（static variable）的意思是该变量在内存中原地不动，并不是说他的值不会变。也被称为**局部静态变量**。

在块中使用`static`可以定义一个静态变量。

> 定义变量的块函数在被外部循环调用时，只会在第一次声明中接受赋值，而在后续的调用中，不会重复接受初始赋值。该例子见12.3代码片段。
{: .prompt-info }

### 12.1.7 外部链接的静态变量

具有文件作用域、外部链接和静态存储期。也称为**外部变量**。

为了指出一个函数使用了外部变量，可以在函数中用`extern`再次声明该变量。

```c
int Errupt; /*外部定义的变量*/
double Up[100]; /*外部定义的数组*/
extern char Coal; /*如果Coal被定义在其他文件，必须这样声明*/

void next(void);
int main(void)
{
    extern int Errupt; /*使用文件变量时的声明，可以不声明直接使用*/
    ...
    double Up[100]; /*声明了新的局部变量，与文件变量Up并非同一个*/
}
void next(void)
{
    ...
}
```

外部变量只能初始化一次，且必须在定义该变量时进行。

### 12.1.8 内部链接的静态变量

```c
int traveler = 1; /*外部链接*/
static int stayhome = 1; /*内部链接*/
int main()
{
    extern int traveler; /*使用定义在别处的traveler*/
    extern int stayhome; /*使用定义在别处的stayhome*/
}
```

> 二者都是静态变量，只不过内部链接只允许本文件的函数使用该变量。
{: .prompt-info }

### 12.1.9 多文件

除了一个定义式声明以外，其他声明都要使用`extern`关键字。

### 12.1.10 存储类别说明符

关键字static、extern的含义取决于上下文。

### 12.1.11 存储类别和函数

函数也有存储类别，分为**外部函数**和**静态函数**。

外部函数可以被其他文件的函数调用，内部函数只能被定义其的文件中的函数调用。

```c
double gamma(double); /*该函数默认为外部函数*/
static double beta(int, int); /*内部函数*/
extern double delta(double, int); /*外部函数*/
```

引用外部函数，一般也用`extern`关键字。

### 12.1.12 存储类别的选择

尽量多使用自动存储类别，尽量少定义外部存储的变量。

使用`const`可以避免数据被修改。

## 12.2 随机数函数和静态变量

ANSI C库提供了一个`rand()`函数生成随机数，使用了内部链接的静态变量。

虽然这一函数有多重算法，会根据机器使用最佳算法，但它有一个可移植的标准算法可供研究。

```c
static unsigned long int next = 1; /*种子*/

unsigned int rand0(void)
{
    /*生成伪随机数的魔术公式*/
    next = next * 1103515245 + 12345;
    return (unsigned int)(next / 65535) % 32768;
}
```

该函数初始种子设为了1，每次调用时，函数的种子则会被修改。

该函数可以返回一个0到32767之间的值。

每次调用该函数，都会获得相同的随机数序列，因此被称为伪随机。这是因为每次都开始于种子1。可以引入另一个函数`srand()`重置种子来解决这个问题。

每次生成随机数，需要输入一个种子。种子不同，则随机数序列不同。

可以用`time()`时间数据作为种子输入。时间一直在变化，这样一来就有了不同的种子来生成随机数。

### 12.3 掷骰子

### 12.4 分配内层：malloc()和free()

用库函数可以更灵活地分配和管理内存。
`malloc()`分配内存，不进行命名，只返回内存块的首字节地址。因此，可以把该地址赋值给一个指针变量，并使用指针访问该内存。

`malloc()`接受一个参数，分配内存的字节数。

```c
double *ptd;
ptd = (double *) malloc(30 * sizeof(double));
```

`malloc()`可以用来定义一个变长数组。如

```c
double *ptd;
ptd = (double *) malloc(n * sizeof(double)); /*n是整型变量*/
```
`free()`用来释放`malloc()`申请的内存，它的参数是一个指针，指向由`malloc()`分配的一块内存。如果`malloc()`调用内存失败，会返回一个空指针。可以调用`exit()`函数结束程序，`malloc()`和`free()`的原型都在stdlib.h头文件中。

### 12.4.1 free()的重要性

如果调用`malloc()`而没有使用`free()`进行内存释放，会造成内存泄漏。

```c
int main()
{
    double glad[2000];
    int i;
    ...
    for (i<0; i<1000; i++)
        gobble(glad, 2000);
}
void gobble
{
    double *temp = (double *) malloc( n * sizeof(double))
    .../* free(temp) ; //假设忘记了free */
}
```
每次调用gobble函数，都会请求2000个double的内存空间，并且函数块运行结束后，temp指针随着内存释放而被自动销毁，但申请的内存还在，却已经无法通过temp访问。再次调用，又会生成新的2000个double的内存空间。

### 12.4.2 calloc()函数

分配内存还可以使用`calloc()`函数，接收2个无符号整数作为参数。`calloc()`函数的特性是把块中所有的位设置为0。

```c
long *newmem;
newmem = (long *) calloc(100, sizeof(long));
```

### 12.4.3 动态内存分配和变长数组

动态内存分配`malloc()`和变长数组VLA功能上有些重合。（C99之后的编译器）

不同的是，变长数组是自动存储类型，程序在离开变长数组定义所在的块时内存会自动释放。另一方面，用`malloc()`创建的数组不必局限于在同一个函数内访问。被调函数创建数组并返回指针，主调函数访问也是可以的并控制`free()`来释放内存也是可以的。

`free()`用的指针变量和`malloc()`的指针变量可以不同，但是必须存储相同的地址。不能用`free()`释放同一块内存两次。

对多维数组而言，使用变长数组比较方便，用`malloc()`创建二维数组也可以，但是语法比较繁琐。

```c
int n = 5;
int m = 6;
int ar2[n][m]; //n*m的变长数组
int (*p3)[m];
p3 = (int (*)[m]) malloc( n * m * sizeof(int));
ar2[1][2] = p3[1][2] = 12;
```
### 12.4.4 存储类别和动态内存分配

程序把静态对象、自动对象和动态分配的对象储存在不同的区域。

静态对象所用的内存数量在编译时确定，程序结束时被销毁。

自动对象根据块定义而增加或减少内存的使用，通常作为栈来处理。

动态分配`malloc()`在调用`free()`时内存才被销毁，所以内存分配支离破碎，使用动态内存通常比使用栈内存慢。

见12.15 where.c程序，静态数据（包括字符串字面量）占用一个区域，自动数据占用一个区域，动态分配的数据占用一个区域（通常称为内存堆或自由内存）。

## 12.5 ANSI C 类型限定符

除了类型和存储类别外，C90新增了两个属性：恒常性(constancy)和易变性(volatile)，关键字是`const`和`volatile`，其创建的类型为限定类型。C99又新增了`restrict`。C11新增了`_Atomic`，提供了一个可选库，由stdatomic.h管理，支持并发设计，是可选项。

C99后，类型限定符是幂等的，一次声明多个限定符，多余的会被自动忽略。

```c
const const const int n = 6; //等同于const int n = 6;
```

### 12.5.1 const类型限定符

`const`关键字声明的变量值不能被修改。

```c
const int nochange = 5; //可以在声明时初始化变量
nochange = 10; //不允许修改

const int days1[5] = {3, 18, 2521, 15, 30};//不允许修改的数组
```

在指针中使用`const`要复杂一些，有两种不同情况：指针本身为`const`还是限定指针指向的值为`const`。

```c
const float * pf; //*pf指向一个float类型的const值,指针指向能改
float const * pf2; //同上
float * const pt; //*pt是一个const指针,指向的地址不能修改
const float * const ptr; //ptr既不能指向别处，它所指向的值也不能改
```

`const`的常见用法是声明为函数形参的指针。在被调函数中，将形参加上`const`关键词，可以保证主调函数调用时，传入的数组名或者地址不会被更改。

```c
void display(const int array[], int limit);//表明不能更改array指向的数据
```
在函数原型和函数头，形参声明`const int array[]`和`const int *array`相同。

ANSI C库沿用了以下规则：如果一个指针仅用于给函数访问值，应将其声明为一个指向`const`限定类型的指针。如果要用指针更改主调函数中的数据，就不使用`const`关键字。ANSI C库中的`strcat()`函数用来将第二个字符串拼接到第一个字符串上，函数原型为：

```C
char *strcat(char * restrict s1, const char * restrict s2);
/*更改了第一个字符，没更改第二个字符*/
```

使用全局变量很冒险，因为暴露了数据，程序的任何部分都能更改数据。如果在全局变量中使用`const`,就能避免这样的危险。

然而，在文件间共享 const 数据要小心。可以采用两个策略。第一，遵循外部变量的常用规则，即在个文件中使用定义式声明，在其他文件中使用引用式声明(用extern关键字):

```c
/*file1.c--定义了一些外部const变量*/
const doublePI=3.14159;
const char*MONTHS[12] = {"January", "February"，"March", "April"，"May", "June", "July"，"August"，"September"，"October", "November", "December"}

/*file2.c--使用定义在别处的外部const变量*/
extern const double PI;
extern const *MONTHS [];
```

另一种方案是，把const 变量放在一个头文件中，然后在其他文件中包含该头文件。

```c
/*constant.h--定义了一些外部const变量*/ 
static const double PI=314159;
static const char *MONTHS[12] ={"January", "February"，"March"，"April"，"May","June"，"July","August"，"September"，"October", "November"，"December"};

/*filel.c--使用定义在别处的外部const 变量*/
#include "constant.h"

/*file2.--使用定义在别处的外部const 变量*/
#include "constant.h"

```

这种方案必须在头文件中用关键字`static`声明全局const变量。

如果去掉`static`,那么在file1.c和file2.c中包含constant.h将导致每个文件中都有一个相同标识符的定义式声明，相当于给每个文件提供了一个单独的数据副本。

由于每个副本只对该文件可见，所以无法用这些数据和其他文件通信。

头文件方案的好处是，方便你偷懒，不用惦记着在一个文件中使用定义式声明，在其他文件中使用引用式声明。所有的文件都只需包含同一个头文件即可。但它的缺点是，数据是重复的。

### 12.5.2 volatile类型限定符

`volatile`限定符告知计算机，代理 (而不是变量所在的程序)可以改变该变量的值。

一般用于硬件地址以及在其他程序或同时运行的线程中共享数据。

例如，一个地址上可能储存着当前的时钟时间，无论程序做什么，地址上的值都随时间的变化而改变。

或者一个地址用于接受另一台计算机传入的信息。

```c
volatile int locl; //locl是一个易变的变量
volatile int *ploc; //ploc是一个指向易变的指针
```

volatile的应用主要在于编译器的优化。

```c
val1=x;
/*一些不使用x的代码*/
val2=X;
```

> 高速缓存(caching):编译器会注意到以上代码使用了两次 ，但并未改变它的值。于是编译器把X的值临时储存在寄存器中，然后在 val2 需要使用时，才从寄存器中(而不是从原始内存位置上)读取值，以节约时间。
> 
> 但是如果其他代理在以上两条语句之间改变了x的值，就不能这样优化了。如果没有 volatile 关键字，编译器就不知道这种事情是否会发生。因此，为安全起见，编译器不会进行高速缓存。现在，如果声明中没有 volatile 关键字，编译器会假定变量的值在使用过程中不变，然后使用告诉缓存。
{: .prompt-info }

`const`和`volatile`可以同时使用。如果一个变量不会被本程序改变，通常可能给它加上`const`；外部程序或硬件可能改变这个量，禁止编译器优化，则会加上`volatile`。同时使用，如以下写法。

```c
volatile const int loc;
const volatile int * ploc;
```

### 12.5.3 restrict类型限定符

`restrict` 只能用于指针，表明该指针是访问数据对象的唯一且初始的方式。

使用`restrict`涉及编译器的优化。

```c
int ar[10];
int *par =ar;
int * restrict restar = (int *) malloc(10 * sizeof(int));

for (n = 0; n < 10; n++)
{
    restar[n]+= 5;
    par[n]+= 5; 
    restar[n]+= 3;
    ar[n] *= 3;
    par[n]+= 5;
}
```
以上例子中，restar使用了`restric`关键词，指针是唯一且初始访问数据的方式，因此后面的for循环中，编译器可以合并对restar的操作，变成`restar[n] += 8`。

par和ar都可以操作同一个数据内容，不能使用`restrict`，因此也不会优化。

`restrict`限定符还可用于函数形参中的指针。这意味着编译器可以假定在函数体内其他标识符不会修改该指针指向的数据，而且编译器可以尝试对其优化，使其不做别的用途。

例如，C 库有两个函数用于把一个位置上的字节拷贝到另一个位置。在C99中，这两个函数的原型是:

```c
void memcpy(void * restrict s1, const void * restrict s2, size_t n);
//把s2位置的字节移动到s1，但是要求s1、s2不能是同一位置
void memmove(void * s1, const void * s2, size_t n);
//把s2位置的字节移动到s1，s1、s2可以是同一位置
```

`restrict`有两个读者，一是告知编译器是否进行优化，二是告知用户要使用满足`restrict`的参数。

### 12.5.4 _Atomic类型限定符（C11）

并发程序设计把程序执行分成可以同时执行的多个线程。

CI1通过包含可选的头文件 stdatomic.h和 threads.h，提供了一些可选的管理方法，通过各种宏函数来访问原子类型。

```c
#include stdatomic.h
#include threads.h

int hogs;//普通声明变量方法
hogs = 5;//可以进行直接赋值

_Atomic int hogs2;//hogs2是原子类型的变量
atomic_store(&hogs2, 12);//stdatomic中的宏
//在这里，其他线程不能访问hogs。
```
原子类型要求编译器支持这一新特性。

### 12.5.5 旧关键字的新位置

C99允许类型限定符和存储类别说明符static放在函数原型和函数头的形参的初始中括号中。

```c
void ofmouth(int * const a1, int * restrict a2, int n);
//旧的语法如上

void ofmouth(int a1[const], int a2[restrict], int n);
//C99允许新的语法
```

static的情况则有些不同。

```c
double stick(double ar[static 20]);
//函数调用中的实参应该是一个指向数组首元素的指针，且该数组至少有20个元素。
//便于编译器使用相关信息优化函数的编码。
```



