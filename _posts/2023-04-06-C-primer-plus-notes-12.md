---
title: C primer plus Notes 12
date: 2023-04-06 18:10:36 +0800
categories: [C]
tags: [Coding, Notes]     # TAG names should always be lowercase
---

# C primer plus Notes 12

## 12 存储类别、链接和内存管理

关键字：auto，extern，static, register, const, volatile, restricted, _Thread_local, _Atomic

函数：rand(), srand(), time(), malloc(), free()

### 12.1存储类别

C语言把一块内存称为 **对象**

```c
int entity = 3
```

该声明创建了一个名为entity的 **标识符（identifier）**。

标识符不是指定对象的唯一途径。

```c
int *pt = &entity;
int ranks[10];
```

可以用**存储期（Storage duration）**描述对象，指对象在内存中保留了多次时间。

标识符用于访问对象，可以用**作用域(scope)**和**链接（linkage）**描述标识符，表明程序的哪些部分可以使用它。

#### 12.1.1 作用域

一个C变量的作用域，可以是**块作用域（block scope）、函数作用域、函数原型作用域、文件作用域**

**块（block）** 是一对花括号括起来的区域，块作用域变量的可见范围是从定义处到包含该定义的块的结尾，也就是说包括形式参数。我们使用的局部变量都具有块作用域。

从C99开始，在块中任意位置都可以声明变量。块的概念扩展到了for、while、do while、if等函数控制的语句。

**函数作用域** 仅作用于go to语句的标签。

**函数原型作用域（function prototype scope）** 用于函数原型中的形参名（变量名）。如 ``int mighty(int mouse, double large);`` 函数原型作用域的范围是从形参定义处到函数结束。编译器在处理函数原型中的形参时只关心它的类型，形参名无关紧要。形参名也不必与函数中的形参名相匹配。只有在变长数组中，形参名才有用： ``void use_a_VLA(int n, int m, ar[n][m]);`` 例子中，n和m必须使用已经在函数原型中声明过的形参。

**文件作用域(file scope)** 变量的定义在函数的外面，也称为**全局变量（global variable）** ,如以下代码中的units变量。

```c
#include <stdio.h>
int units = 0; 
int main(void){
    ...
}
```

**翻译单元（translation units）** ：编译器把源代码中的头文件内容替换#include指令，因此一个源代码和其头文件共同构成一个翻译单元，文件作用域实际上作用于整个翻译单元。如果程序由多个源代码文件组成，那么该程序也将由多个翻译单元组成。

### 12.1.2 链接

C变量有3种链接属性:**外部链接**、**内部链接**或**无链接**。

无链接变量：具有块作用域、函数作用域或函数原型作用域的变量。这些变量属于定义它们的块、函数或原型私有。

具有文件作用域的变量可以是外部链接或内部链接。

外部链接变量可以在多文件程序中使用，内部链接变量只能在一个**翻译单元**中使用。

因此：

内部链接：文件作用域。 例如``static int dodgers = 3;``,仅作用于本翻译单元。

外部链接：全局作用域（或程序作用域）。例如``int giant = 5;``作用于同一程序的所有文件（翻译单元）。

### 12.1.3 存储期

作用域和链接描述了标识符的可见性。**存储期**描述了通过这些标识符访问的对象的生存期。

C对象有4种存储期：**静态存储期**、**线程存储期**、**自动存储期**、**动态分配存储期**。

**静态存储期**：在程序的执行期间一直存在。文件作用域变量具有静态存储期。
注意，对于文件作用域变量，关键字 static 表明了其链接属性，而非存储期。以 static 声明的文件作用域变量具有内部链接。但是无论是内部链接还是外部链接，所有的文件作用域变量都具有静态存储期。

**线程存储期**：用于并发程序设计，程序执行可被分为多个线程。具有线程存储期的对象，从被声明时到线程结束一直存在。以关键字 Thread local声明一个对象时，每个线程都获得该变量的私有备份。

**自动存储期**：大部分 块作用域 的变量。当程序进入定义这些变量的块时，为这些变量分配内存;当退出这个块时，释放刚才为变量分配的内存。这种做法相当于把自动变量占用的内存视为一个可重复使用的工作区或暂存区。例如，一个函数调用结束后，其变量占用的内存可用于储存下一个被调用函数的变量。变长数组稍有不同，它们的存储期从声明处到块的末尾，而不是从块的开始处到块的末尾。

块作用域变量也能具有静态存储期。为了创建这样的变量，要把变量声明在块中，且在声明前面加上关键字static，例如以下代码：
```c
void more(int number)
{
    int index;
    static int ct = 0; //ct变量具有静态存储期，因为命名时有static
    ...
    return 0;
}
```
``ct``的作用域没有发生改变，只有执行该函数时，程序才能使用``ct``访问其对象。但由于具有静态存储期，该函数可以通过提供给其他函数该存储区的地址，就可以访问该对象，例如通过指针形参或返回值）。

作用域、链接和存储期互相组合，具有5种存储类别（除去并发程序设计）。

|存储类别|存储期|作用域|链接|声明方式|
|---|---|---|---|---|
|自动|自动|块|无|块内|
|寄存器|自动|块|无|块内，使用关键字register|
|静态外部链接|静态|程序多个文件|外部|所有函数外|
|静态内部链接|静态|单个文件|内部|所有函数外，使用关键字static|
|静态无链接|静态|块|无|块内，使用static|

### 12.1.4 自动变量

声名在块或函数头中的变量一般都是自动变量。

可以显式使用关键字 ``auto``，表明有意覆盖一个外部变量定义，或者强调不要把该变量改为其他存储类别，如下所示:

```c
int main(void){
    auto int plox;
}
```
``auto``在C和C++的定义完全不同，在C/C++兼容编程中不要使用。

如果块的内层和外层定义了同名的变量，在内层块会隐藏外层快的定义。但是离开内层块后，外层块的作用域回到原来的作用域。

```c
#include <stdio.h>
int x = 30;
int main()
{
    while(x ++ <33)
    {
        int x = 100;
        x ++;
        printf("x in while loop: %d at %p\n", x, &x)
    }
    printf("x in outer block: %d at %p\n", x, &x);
}
```

### 12.1.5 寄存器变量

使用`regitster`来申请在寄存器中储存变量。
寄存器中变量储存速度更快，但是无法获取地址。

寄存器变量：块作用域，无链接，自动存储期。

编译器不一定会响应寄存器变量的申请。

### 12.1.6 块作用域的静态变量

静态变量（static variable）的意思是该变量在内存中原地不动，并不是说他的值不会变。也被称为**局部静态变量**。

在块中使用`static`可以定义一个静态变量。

> 定义变量的块函数在被外部循环调用时，只会在第一次声明中接受赋值，而在后续的调用中，不会重复接受初始赋值。该例子见12.3代码片段。
{: .prompt-info }

### 12.1.7 外部链接的静态变量

具有文件作用域、外部链接和静态存储期。也称为**外部变量**。

为了指出一个函数使用了外部变量，可以在函数中用`extern`再次声明该变量。

```c
int Errupt; /*外部定义的变量*/
double Up[100]; /*外部定义的数组*/
extern char Coal; /*如果Coal被定义在其他文件，必须这样声明*/

void next(void);
int main(void)
{
    extern int Errupt; /*使用文件变量时的声明，可以不声明直接使用*/
    ...
    double Up[100]; /*声明了新的局部变量，与文件变量Up并非同一个*/
}
void next(void)
{
    ...
}
```

外部变量只能初始化一次，且必须在定义该变量时进行。

### 12.1.8 内部链接的静态变量

```c
int traveler = 1; /*外部链接*/
static int stayhome = 1; /*内部链接*/
int main()
{
    extern int traveler; /*使用定义在别处的traveler*/
    extern int stayhome; /*使用定义在别处的stayhome*/
}
```

> 二者都是静态变量，只不过内部链接只允许本文件的函数使用该变量。
{: .prompt-info }

### 12.1.9 多文件

除了一个定义式声明以外，其他声明都要使用`extern`关键字。

### 12.1.10 存储类别说明符

关键字static、extern的含义取决于上下文。

### 12.1.11 存储类别和函数

函数也有存储类别，分为**外部函数**和**静态函数**。

外部函数可以被其他文件的函数调用，内部函数只能被定义其的文件中的函数调用。

```c
double gamma(double); /*该函数默认为外部函数*/
static double beta(int, int); /*内部函数*/
extern double delta(double, int); /*外部函数*/
```

引用外部函数，一般也用`extern`关键字。

### 12.1.12 存储类别的选择

尽量多使用自动存储类别，尽量少定义外部存储的变量。

使用`const`可以避免数据被修改。

## 12.2 随机数函数和静态变量

ANSI C库提供了一个`rand()`函数生成随机数，使用了内部链接的静态变量。

虽然这一函数有多重算法，会根据机器使用最佳算法，但它有一个可移植的标准算法可供研究。

```c
static unsigned long int next = 1; /*种子*/

unsigned int rand0(void)
{
    /*生成伪随机数的魔术公式*/
    next = next * 1103515245 + 12345;
    return (unsigned int)(next / 65535) % 32768;
}
```

该函数初始种子设为了1，每次调用时，函数的种子则会被修改。

该函数可以返回一个0到32767之间的值。

每次调用该函数，都会获得相同的随机数序列，因此被称为伪随机。这是因为每次都开始于种子1。可以引入另一个函数`srand()`重置种子来解决这个问题。

每次生成随机数，需要输入一个种子。种子不同，则随机数序列不同。

可以用`time()`时间数据作为种子输入。时间一直在变化，这样一来就有了不同的种子来生成随机数。

### 12.3 掷骰子

### 12.4 分配内层：malloc()和free()

用库函数可以更灵活地分配和管理内存。
malloc()分配内存，不进行命名，只返回内存块的首字节地址。因此，可以把该地址赋值给一个指针变量，并使用指针访问该内存。

malloc()接受一个参数，分配内存的字节数。

```c
double *ptd;
ptd = (double *) malloc(30 * sizeof(double));
```

